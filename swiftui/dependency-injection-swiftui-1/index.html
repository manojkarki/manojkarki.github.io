<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="YoSwift!"/><link rel="canonical" href="https://yoswift.dev/swiftui/dependency-injection-swiftui-1"/><meta name="twitter:url" content="https://yoswift.dev/swiftui/dependency-injection-swiftui-1"/><meta name="og:url" content="https://yoswift.dev/swiftui/dependency-injection-swiftui-1"/><title>Declarative dependency injection in SwiftUI - 1 | YoSwift!</title><meta name="twitter:title" content="Declarative dependency injection in SwiftUI - 1 | YoSwift!"/><meta name="og:title" content="Declarative dependency injection in SwiftUI - 1 | YoSwift!"/><meta name="description" content="Declarative dependency Injection in SwiftUI - 1"/><meta name="twitter:description" content="Declarative dependency Injection in SwiftUI - 1"/><meta name="og:description" content="Declarative dependency Injection in SwiftUI - 1"/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to YoSwift!"/><meta name="twitter:image" content="https://yoswift.dev/images/logo.png"/><meta name="og:image" content="https://yoswift.dev/images/logo.png"/></head><body class="item-page"><header><a id="logo" href="/"><img src="/images/logo.png" alt="Yo! Swift"/></a><nav id="main-navigation"><ul><li><a class="selected" href="/swiftui">SwiftUI</a></li><li><a href="/swift">Swift</a></li><li><a href="/combine">Combine</a></li><li><a href="/about">About</a></li><li><a href="/apps">Apps</a></li></ul></nav></header><div class="wrapper"><span>Published on: Jul 20, 2020</span><article><div class="content"><h1>Declarative dependency injection in SwiftUI - 1</h1><p>Dependency Injection (<strong>DI</strong>) is such a heavy word for a concept we all do all the time unknowingly ðŸ˜Ž It is simply passing "dependencies" of an object via initializer or properties or also via methods.</p><blockquote><p>In software engineering, <em>dependency injection</em> is a technique in which an object receives other objects that it depends on.</p></blockquote><p>SwiftUI declarative syntax made <strong>DI</strong> a bit non-obvious for beginners, this article (and the part 2 of it) will explain a way of <strong>DI</strong> in SwiftUI and hopefully you won't find it unusual after reading these.</p><br /><p>Check the below code snippet.</p><pre><code><span class="keyword">struct</span> ContentView: <span class="type">View</span> {
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">Text</span>(<span class="string">"Hello world"</span>)
            .<span class="call">font</span>(.<span class="dotAccess">largeTitle</span>)
    }
}
</code></pre><br /><p>There is nothing interesting going on here, we created a Text object and calling a SwiftUI method available on Text to change the font.</p><pre><code>  <span class="keyword">func</span> font(<span class="keyword">_</span> font: <span class="type">Font</span>?) -&gt; <span class="type">Text</span>
</code></pre><br /><p>Let's add a default padding around Text</p><br /><pre><code><span class="keyword">struct</span> ContentView: <span class="type">View</span> {
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">Text</span>(<span class="string">"Hello world"</span>)
            **.<span class="call">padding</span>()**
            .<span class="call">font</span>(.<span class="dotAccess">largeTitle</span>)
    }
}
</code></pre><br /><p>What has changed, well nothing much you might say but a lot. We now have <strong>DI</strong> in picture ðŸ¤¯</p><p>Note the following points here</p><ol><li>We now no longer calling the <strong>font</strong> method on <strong>Text</strong> object but on return type of <strong>padding()</strong> method</li><li><strong>padding</strong> a method on View returns another View of type <strong>SwiftUI.ModifiedContent&lt;SwiftUI.Text, SwiftUI._PaddingLayout&gt;</strong> so if you know about opaque return type (<a href="https://yoswift.dev/combine/advanced-swift-quiz/">if not check Answer 3 here</a>) we can also say return value is <strong>some View</strong></li><li>Setting font on non-text View like padding type make no sense but still font will get applied magically to <strong>Text</strong> inside that View.</li></ol><br /><p>Let's write above code in a non-declarative way (i.e. Imperative) to understand better what is going on here.</p><pre><code><span class="keyword">struct</span> ContentViewImp: <span class="type">View</span> {
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="keyword">let</span> text = <span class="type">Text</span>(<span class="string">"Hello world"</span>)
        <span class="keyword">let</span> someView1 = text.<span class="call">padding</span>()
      	<span class="keyword">let</span> fontDependency = <span class="type">Font</span>.<span class="property">largeText</span>
        <span class="keyword">let</span> someView2 = someView1.<span class="call">font</span>(fontDependency)
        <span class="keyword">return</span> someView2
    }
} 
</code></pre><br /><p>The text is a child of someView1 and the font method called on someView1 is actually where you are passing/injecting the dependency Font to someView1. All Views are implicitly provided with many dependencies (called Environment Values) by SwiftUI and all those values make a View's Environment.</p><br /><p>The call font on someView1 is actually just changing the default environment value of Font to Font.largeText in its environment. This overridden Font value will then be available (injected) to all child views <strong>no matter how deep they are</strong> in the view tree. This is the reason text shows up using largeText as it is reading the font from the environment (injected by parent someView1).</p><br /><p>In fact the font method on View is just a syntactic sugar for setting font on environment. So the code below is equivalent</p><pre><code><span class="keyword">struct</span> ContentView: <span class="type">View</span> {
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">Text</span>(<span class="string">"Hello world"</span>)
            .<span class="call">padding</span>()
            **.<span class="call">environment</span>(\<span class="type">EnvironmentValues</span>.<span class="property">font</span>, .<span class="dotAccess">caption</span>)**
    }
}
</code></pre><br /><p>The environment declaration is like this</p><pre><code><span class="keyword">func</span> environment&lt;V&gt;(<span class="keyword">_</span> keyPath: <span class="type">WritableKeyPath</span>&lt;<span class="type">EnvironmentValues</span>, <span class="type">V</span>&gt;, <span class="keyword">_</span> value: <span class="type">V</span>) -&gt; <span class="keyword">some</span> <span class="type">View</span>
</code></pre><p>It takes a keypath <strong>WritableKeyPath&lt;EnvironmentValues, V&gt;</strong> to change a value in environment of a particular view hierarchy. In this case we are injecting font value to <a href="https://developer.apple.com/documentation/swiftui/environmentvalues/font">one of the property of EnvironmentValues called font</a></p><p>Now you understand that when we apply font to a container like VStack we are just setting the value of font property of EnvironmentValues of VStack and all child views of VStack get the new Font value implicitly from the environment.</p><pre><code><span class="keyword">struct</span> ContentView: <span class="type">View</span> {
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">VStack</span> {
            <span class="type">Text</span>(<span class="string">"Hello world"</span>)
        }
        .<span class="call">font</span>(<span class="type">Font</span>.<span class="property">largeTitle</span>)
    }
}
</code></pre><p>Check <a href="https://developer.apple.com/documentation/swiftui/environmentvalues">EnvironmentValues</a> and you will see that there are many useful properties that get implicitly be available to <strong>all subviews</strong> via Environment. You can override (inject) any of these for a view hierarchy as we did above for font.</p><p>This is how we inject a dependency via <strong>environment</strong> method. We haven't seen yet how the injected value is being received by the child views. Above examples you can't see as the consumer View is Text View part of SwiftUI framework.</p><p><a href="https://yoswift.dev/swiftui/dependency-injection-swiftui-2/">In the second part</a> we will dig deeper into how to receive the injected dependency in the subviews and also how to inject our own custom dependencies to a view hierarchy.</p></div><span>Tagged with: </span><br/><ul class="tag-list-swiftui"><li><a href="/tags/swiftui">SwiftUI</a></li><li><a href="/tags/dependency-injection">Dependency Injection</a></li><li><a href="/tags/environment">Environment</a></li></ul></article></div><footer><p>Coded in Swift, generated using <a href="https://github.com/johnsundell/publish">Publish</a></p><p><a href="/feed.rss">RSS feed</a></p></footer></body></html>