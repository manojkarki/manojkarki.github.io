<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="YoSwift!"/><link rel="canonical" href="https://yoswift.dev/swift/recursive_objects"/><meta name="twitter:url" content="https://yoswift.dev/swift/recursive_objects"/><meta name="og:url" content="https://yoswift.dev/swift/recursive_objects"/><title>Recursive Objects | YoSwift!</title><meta name="twitter:title" content="Recursive Objects | YoSwift!"/><meta name="og:title" content="Recursive Objects | YoSwift!"/><meta name="description" content="Value type cannot have a stored property that recursively contains it?"/><meta name="twitter:description" content="Value type cannot have a stored property that recursively contains it?"/><meta name="og:description" content="Value type cannot have a stored property that recursively contains it?"/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to YoSwift!"/><meta name="twitter:image" content="https://yoswift.dev/images/logo.png"/><meta name="og:image" content="https://yoswift.dev/images/logo.png"/></head><body class="item-page"><header><a id="logo" href="/"><img src="/images/logo.png" alt="Yo! Swift"/></a><nav id="main-navigation"><ul><li><a href="/swiftui">SwiftUI</a></li><li><a class="selected" href="/swift">Swift</a></li><li><a href="/combine">Combine</a></li><li><a href="/about">About</a></li><li><a href="/apps">Apps</a></li></ul></nav></header><div class="wrapper"><span>Published on: May 30, 2020</span><article><div class="content"><h1>Recursive Objects</h1><p>Earlier we learnt about how we can <a href="https://yoswift.dev/swift/Tree%20in%20Swift/">implement a binary tree in Swift.</a> Remember we started with a Class and not a struct.</p><p>Let's try to understand the problem with using a struct. Try compiling the code below.</p><pre><code><span class="keyword">struct</span> Node {
    <span class="keyword">var</span> next: <span class="type">Node</span>
}
</code></pre><p>It will not compile and give you an error.</p><blockquote><p><strong>value type 'Node' cannot have a stored property that recursively contains it</strong></p></blockquote><p>The reason is, the compiler need to know the memory size of struct node so that it can allocate memory for variables / constants of this type in <a href="https://en.wikipedia.org/wiki/Stack-based_memory_allocation">Stack</a>. Now due to the recursive nature of the struct it means it is an infinite size and compiler cannot allow it.</p><p>Now, what do you think about the code below</p><pre><code><span class="keyword">struct</span> Node {
    <span class="keyword">var</span> next: [<span class="type">Node</span>]
}
</code></pre><p>Well, it compiles fine, which feels a bit weird to some, if you are confused by this go ahead and read the explanation below.</p><p>If you think about it <code>Array</code> in Swift is also a <em>value type</em> meaning compiler need to know the size of an Array in advance. But also the array need to hold <strong>variable</strong> number of elements which it cannot know in advance and hence it need to allocate memory for those elements in <a href="https://en.wikipedia.org/wiki/Memory_management">heap</a> and hold a reference (or pointer) to that memory.</p><p>The references are fixed size and so Array has a fixed size (size of a reference to actual array elements + other fixed size elements for book keeping and other implementation details.)</p><p>Now it is an Array's implementation detail that gives you value type semantic despite it containing a reference type. It does it <strong>lazily</strong> meaning copying only when required.</p><pre><code><span class="keyword">struct</span> Node {
    <span class="keyword">var</span> value: <span class="type">Int</span>
    <span class="keyword">var</span> kids: [<span class="type">Node</span>]
}

<span class="keyword">var</span> n1 = <span class="type">Node</span>(value: <span class="number">1</span>, kids: [ <span class="type">Node</span>(value: <span class="number">2</span>, kids: []) ])
<span class="keyword">var</span> n2 = n1
</code></pre><p>When we copy n1 to n2, we expect a <strong>new memory</strong> for kids array of n2 and all n1's array elements <strong>copied</strong> to it. This is because being a value type we expect a value type semantic from Array. Now to optimize unnecessary copy operations Array can actually delay this copy operation and hold until one of n1 or n2 try to mutate their kids array (e.g. remove or add a new element).</p><p>So far essentially it mean both reference inside n1 and n2 are actually pointing to the same memory location where the elements are stored.</p><pre><code>n2.<span class="property">kids</span>.<span class="call">append</span>(<span class="type">Node</span>(value: <span class="number">3</span>, kids: []))
</code></pre><p>Now at this point, Array implementation will actually allocate a new memory for holding kids of n2, add the new Node in that memory and change the reference inside n2 to point to this memory.</p><p>All these details are Array's internal implementation details but it is good to know what is going on inside to explain some concepts we get confused with while using an Array.</p></div><span>Tagged with: </span><br/><ul class="tag-list-swift"><li><a href="/tags/swift">swift</a></li><li><a href="/tags/recursive-objects">recursive objects</a></li><li><a href="/tags/array">Array</a></li></ul></article></div><footer><p>Coded in Swift, generated using <a href="https://github.com/johnsundell/publish">Publish</a></p><p><a href="/feed.rss">RSS feed</a></p></footer></body></html>