<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content"><channel><title>YoSwift!</title><description>Short tips, tricks and best practices for using Swift, SwiftUI and Combine.</description><link>https://www.yoswift.com</link><language>en</language><lastBuildDate>Sun, 3 May 2020 15:45:11 +0200</lastBuildDate><pubDate>Sun, 3 May 2020 15:45:11 +0200</pubDate><ttl>250</ttl><atom:link href="https://www.yoswift.com/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://www.yoswift.com/swift/statusbar-style</guid><title>SwiftUI View and status bar style</title><description>How to change status bar style for each SwiftUI screen or View</description><link>https://www.yoswift.com/swift/statusbar-style</link><pubDate>Sun, 3 May 2020 15:00:00 +0200</pubDate><content:encoded><![CDATA[<h1>SwiftUI View and status bar style</h1><p>In UIKit we can override preferredStatusBarStyle to change the status bar style.</p><br /><pre><code><span class="keyword">class</span> MyViewController: <span class="type">UIViewController</span> {
    <span class="keyword">override var</span> preferredStatusBarStyle: <span class="type">UIStatusBarStyle</span> {
        <span class="keyword">return</span> .<span class="dotAccess">lightContent</span>
    }
}
</code></pre><br /><p>Now when you push another SwiftUI View to NavigationView, there is no way to change the status bar style for the screen you are pushing.</p><br /><pre><code><span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
    <span class="type">HStack</span> {
        <span class="type">NavigationLink</span>(destination: <span class="type">AnotherScreenView</span>()) {
            <span class="type">Text</span>(<span class="string">"Push another screen"</span>)                
        }        
    }
}
</code></pre><br /><p>A small trick is to always create a new instance of UIHostingController and change statusbar as required.</p><br /><br /><p>First create a subclass of UIHostingController that takes statusBarStyle.</p><br /><pre><code><span class="keyword">class</span> HostingController: <span class="type">UIHostingController</span>&lt;<span class="type">AnyView</span>&gt; {

    <span class="keyword">var</span> statusBarStyle: <span class="type">UIStatusBarStyle</span>

    <span class="keyword">init</span>(rootView: <span class="type">AnyView</span>, statusBarStyle : <span class="type">UIStatusBarStyle</span> = .<span class="dotAccess">lightContent</span>) {
        <span class="keyword">self</span>.<span class="property">statusBarStyle</span> = statusBarStyle
        <span class="keyword">super</span>.<span class="keyword">init</span>(rootView: rootView)
    }

    <span class="keyword">override var</span> preferredStatusBarStyle: <span class="type">UIStatusBarStyle</span> {
        statusBarStyle
    }
}
</code></pre><br /><p>A small router that holds the UINavigationController, and injected to view hierarchy as an environment object of root view. The only method is push taking a root view and statusBarStyle.</p><br /><pre><code>     <span class="keyword">let</span> navigationController: <span class="type">UINavigationController</span>
    
    <span class="keyword">init</span>(navigationController: <span class="type">UINavigationController</span>) {
        <span class="keyword">self</span>.<span class="property">navigationController</span> = navigationController
    }
    
    <span class="keyword">func</span> push(<span class="keyword">_</span> view: <span class="type">AnyView</span>, statusBarStyle : <span class="type">UIStatusBarStyle</span> = .<span class="dotAccess">lightContent</span>) {
        <span class="keyword">let</span> hostingController =  <span class="type">HostingController</span>(rootView: view, statusBarStyle: statusBarStyle:)
        <span class="keyword">self</span>.<span class="property">navigationController</span>.<span class="call">pushViewController</span>(hostingController, animated: <span class="keyword">true</span>)
    }
}
</code></pre><br /><p>Make a small replacement for SwiftUI's NavigationLink.</p><br /><pre><code><span class="keyword">struct</span> MyNavigationLink&lt;Destination: <span class="type">View</span>, Content: <span class="type">View</span>&gt;: <span class="type">View</span> {
    <span class="keyword">@EnvironmentObject 
    var</span> router: <span class="type">Router</span>
    <span class="keyword">let</span> destination: <span class="type">Destination</span>

    <span class="keyword">let</span> viewBuilder: () -&gt; <span class="type">Content</span>
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">Button</span>(action: {        
        <span class="keyword">self</span>.<span class="property">router</span>.<span class="call">push</span>(<span class="type">AnyView</span>(<span class="keyword">self</span>.<span class="property">destination</span>), statusBarStyle: .<span class="dotAccess">lightContent</span>)
        }) {
            <span class="call">viewBuilder</span>()
        }
    }
}
</code></pre><br /><p>Now usage is simple</p><br /><pre><code><span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
    <span class="type">HStack</span> {
    <span class="type">MyNavigationLink</span>(destination: <span class="type">AnotherScreenView</span>(), statusBarStyle: .<span class="dotAccess">darkContent</span>) {
            <span class="type">Text</span>(<span class="string">"Push another screen"</span>)                
        }        
    }
}
</code></pre><br />]]></content:encoded></item><item><guid isPermaLink="true">https://www.yoswift.com/swiftui/swiftui-conditional-view</guid><title>Conditionally render a different View</title><description>How to conditionally render a different View</description><link>https://www.yoswift.com/swiftui/swiftui-conditional-view</link><pubDate>Sun, 3 May 2020 12:35:00 +0200</pubDate><content:encoded><![CDATA[<h1>Conditionally render a different View</h1><p>Well, most of the SwiftUI beginner do try this which compiler won't compile</p><br /><pre><code><span class="keyword">func</span> textOrImage(<span class="keyword">_</span> text: <span class="type">Bool</span>) -&gt; <span class="keyword">some</span> <span class="type">View</span> {
    text ? <span class="type">Text</span>(<span class="string">"Hello"</span>) : <span class="type">Image</span>(systemName: <span class="string">"headphones"</span>)
}
</code></pre><br /><p>If you don't understand why, read about <a href="https://docs.swift.org/swift-book/LanguageGuide/OpaqueTypes.html"><code></code><code>some</code><code></code></a> keyword,</p><p>in short it is a shorthand to avoid writing long generic types but still compiler will check that function returns the same concrete type from all return paths.</p><br /><p>Also don't even try to do this</p><pre><code><span class="keyword">func</span> textOrImage(<span class="keyword">_</span> text: <span class="type">Bool</span>) -&gt; <span class="type">Group</span> {
    text ? <span class="type">Group</span> { <span class="type">Text</span>(<span class="string">"Hello"</span>) } : <span class="type">Group</span> { <span class="type">Image</span>(systemName: <span class="string">"headphones"</span>) }
}
</code></pre><br /><p>Group is a generic so a concrete type is <code></code><code>Group&lt;Text&gt;</code><code></code> or <code></code><code>Group&lt;Image&gt;</code><code></code>, but you can't return both.</p><br /><p>Type erased view <a href="https://developer.apple.com/documentation/swiftui/anyview">AnyView</a> can be used here.</p><pre><code><span class="keyword">func</span> textOrImage(<span class="keyword">_</span> text: <span class="type">Bool</span>) -&gt; <span class="type">AnyView</span> {
    text ? <span class="type">AnyView</span>(<span class="type">Text</span>(<span class="string">"Hello"</span>)) : <span class="type">AnyView</span>(<span class="type">Image</span>(systemName: <span class="string">"headphones"</span>))
}
</code></pre><br /><p>But important to note this from the documentation.</p><p><em>"Whenever the type of view used with an AnyView changes, the old hierarchy is destroyed and a new hierarchy is created for the new type."</em></p><br /><p>One implication of this is that, as SwiftUI system need to discard the whole view hierarchy, in some case it mess with the animation (more on it later).</p><br /><p>Another way is to do something like this</p><pre><code><span class="keyword">func</span> textOrNil(<span class="keyword">_</span> text: <span class="type">Bool</span>) -&gt; <span class="type">Text</span>? {
    <span class="keyword">guard</span> text <span class="keyword">else</span> { <span class="keyword">return nil</span> }
    <span class="keyword">return</span> <span class="type">Text</span>(<span class="string">"Hello"</span>)
}

<span class="keyword">func</span> imageOrNil(<span class="keyword">_</span> text: <span class="type">Bool</span>) -&gt; <span class="type">Image</span>? {
    <span class="keyword">guard</span> text <span class="keyword">else</span> { <span class="keyword">return</span> <span class="type">Image</span>(systemName: <span class="string">"headphones"</span>) }
    <span class="keyword">return nil</span>
}
</code></pre><br /><p>It is perfectly fine to then use these methods like below</p><pre><code><span class="keyword">var</span> isText: <span class="type">Bool
VStack</span> {
    <span class="call">textOrNil</span>(isText)
    <span class="call">imageOrNil</span>(isText)
}

<span class="comment">//same as wiring</span>
<span class="type">VStack</span> {
    <span class="type">ViewBuilder</span>.<span class="call">buildIf</span>(<span class="call">textOrNil</span>(isText))
    <span class="type">ViewBuilder</span>.<span class="call">buildIf</span>(<span class="call">imageOrNil</span>(isText))
}

</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://www.yoswift.com/swift/readonly-property</guid><title>Readonly properties</title><description>Readonly properties with auto- synthesized intializers.</description><link>https://www.yoswift.com/swift/readonly-property</link><pubDate>Sat, 2 May 2020 12:35:00 +0200</pubDate><content:encoded><![CDATA[<h1>Readonly properties</h1><p>In a struct you can mark a property readonly like</p><pre><code><span class="keyword">struct</span> Example1 {
    <span class="keyword">private(set) var</span> value: <span class="type">Int</span>
}
</code></pre><p>This is another way of marking a property readonly</p><pre><code><span class="keyword">struct</span> Example2 {
    <span class="keyword">let</span> value: <span class="type">Int</span>
}
</code></pre><p>There is an important difference though, the below code will compile just fine</p><pre><code><span class="keyword">var</span> example1 = <span class="type">Example</span>(value: <span class="number">10</span>)
example1.<span class="property">value</span> = <span class="number">20</span>
</code></pre><p>while below code will not compile with <span style="color:red"> error: cannot assign to property: 'value' is a 'let' constant </span></p><pre><code><span class="keyword">var</span> example2 = <span class="type">Example2</span>(value: <span class="number">10</span>)
example2.<span class="property">value</span> = <span class="number">20</span>
</code></pre><p>and by using private(set) you can provide a default value to your property, and initializer can be called</p><p>with or without an argument.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.yoswift.com/combine/keyboard-height</guid><title>Keyboard handling using combine</title><description>Reactive way to handle keyboard height change</description><link>https://www.yoswift.com/combine/keyboard-height</link><pubDate>Sat, 2 May 2020 12:35:00 +0200</pubDate><content:encoded><![CDATA[<h1>Keyboard handling using combine</h1><pre><code><span class="keyword">static var</span> keyboardHeightPublisher: <span class="type">AnyPublisher</span>&lt;<span class="type">CGFloat</span>, <span class="type">Never</span>&gt; {
    <span class="keyword">let</span> willShow = <span class="type">NotificationCenter</span>.<span class="property">default</span>.<span class="call">publisher</span>(for: <span class="type">UIApplication</span>.<span class="property">keyboardWillShowNotification</span>)
        .<span class="call">map</span> { $0.(userInfo?[<span class="type">UIResponder</span>.<span class="property">keyboardFrameEndUserInfoKey</span>] <span class="keyword">as</span>? <span class="type">CGRect</span>)?.<span class="property">height</span> ?? <span class="number">0</span> }

    <span class="keyword">let</span> willHide = <span class="type">NotificationCenter</span>.<span class="property">default</span>.<span class="call">publisher</span>(for: <span class="type">UIApplication</span>.<span class="property">keyboardWillHideNotification</span>)
        .<span class="call">map</span> { <span class="keyword">_ in</span> <span class="type">CGFloat</span>(<span class="number">0</span>) }

    <span class="keyword">return</span> <span class="type">MergeMany</span>(willShow, willHide)
        .<span class="call">eraseToAnyPublisher</span>()
}
</code></pre><p>Now you can subscibe easily to keyboard height changes.</p><pre><code><span class="keyword">struct</span> ContentView: <span class="type">View</span> {
    
    <span class="keyword">@State 
    private var</span> value: <span class="type">String</span>

    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">TextField</span>(<span class="string">"Enter the value"</span>, text: $value)
            .<span class="call">onReceive</span>(keyboardHeightPublisher) { keyboardHeight <span class="keyword">in
                if</span> keyboardHeight &gt; <span class="number">0</span> {
                    <span class="call">print</span>(<span class="string">"Move something up"</span>)
                }
            }
    }
}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://www.yoswift.com/swiftui/swiftui-with-uilabel</guid><title>Using UILabel in SwiftUI</title><description>How to use a multiline UILabel in SwiftUI.</description><link>https://www.yoswift.com/swiftui/swiftui-with-uilabel</link><pubDate>Sat, 2 May 2020 12:35:00 +0200</pubDate><content:encoded><![CDATA[<h1>Using UILabel in SwiftUI</h1><p>But why 😀 well sometime using SwiftUI in an existing App force you to do so.</p><p>So here is a SwiftUI View using <code></code><code>Text</code><code></code></p><pre><code><span class="keyword">struct</span> ContentView: <span class="type">View</span> {
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">VStack</span> {
            <span class="type">Text</span>(<span class="string">"This is a SwiftUI text which is easy to use but you need to understand the SwiftUI layout engine."</span>)
                .<span class="call">background</span>(<span class="type">Color</span>.<span class="property">black</span>)
                .<span class="call">foregroundColor</span>(<span class="type">Color</span>.<span class="property">white</span>)
        }
        .<span class="call">frame</span>(width: <span class="number">200</span>)
    }
}
</code></pre><p>Because <code></code><code>Text</code><code></code> has no frame, it gets it width from the parent which is a VStack and you see a nice multiline text constrained</p><p>by width of the parent 200 pts.</p><br /><img src="swiftui-with-uilabel-1.png "Multiline Text in SwiftUI"" alt="Multiline Text in SwiftUI"/><br /><br /><p>Now to use UILabel and produce the similar output this is what we need.</p><pre><code><span class="keyword">struct</span> SUILabel: <span class="type">UIViewRepresentable</span> {

    <span class="keyword">private(set) var</span> preferredMaxLayoutWidth: <span class="type">CGFloat</span> = <span class="number">0</span>
    <span class="keyword">func</span> makeUIView(context: <span class="type">UIViewRepresentableContext</span>&lt;<span class="type">SUILabel</span>&gt;) -&gt; <span class="type">UILabel</span> {
        <span class="keyword">let</span> label = <span class="type">UILabel</span>()
        label.<span class="property">text</span> = <span class="string">"""
        This is UILabel, one of the most interesting View class in UIKit. 
        With autolayout and multiline and it often give you some surprises. 
        Now using it with SwiftUI = 🤯
        """</span>
        label.<span class="property">numberOfLines</span> = <span class="number">0</span>
        label.<span class="property">preferredMaxLayoutWidth</span> = preferredMaxLayoutWidth
        label.<span class="property">backgroundColor</span> = <span class="type">UIColor</span>.<span class="property">black</span>
        label.<span class="property">textColor</span> = <span class="type">UIColor</span>.<span class="property">white</span>
        <span class="keyword">return</span> label
    }

    <span class="keyword">func</span> updateUIView(<span class="keyword">_</span> uiView: <span class="type">UILabel</span>, context: <span class="type">UIViewRepresentableContext</span>&lt;<span class="type">SUILabel</span>&gt;) { }
}
</code></pre><p>Now use SUILabel in SwiftUI view</p><pre><code><span class="keyword">struct</span> ContentView: <span class="type">View</span> {
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">VStack</span> {
            <span class="type">GeometryReader</span> { geometry <span class="keyword">in</span>
                <span class="type">SUILabel</span>(preferredMaxLayoutWidth: geometry.<span class="property">size</span>.<span class="property">width</span>)
                .<span class="call">fixedSize</span>(horizontal: <span class="keyword">true</span>, vertical: <span class="keyword">true</span>)
            }
        }
        .<span class="call">frame</span>(width: <span class="number">200</span>)
    }
}
</code></pre><p>The important things to note are, the use of <a href="https://developer.apple.com/documentation/uikit/uilabel/1620534-preferredmaxlayoutwidth"><strong>preferredMaxLayoutWidth</strong></a> onUILabel,</p><p><a href="https://developer.apple.com/documentation/swiftui/geometryreader"><strong>GeometryReader</strong></a> to fed it to SUILabel and using <a href="https://developer.apple.com/documentation/swiftui/group/3284808-fixedsize"><strong>fixedSize</strong></a> on SUILabel</p><p>to force SwiftUIlayout engine to use the original size ( in UIKit words, <a href="https://developer.apple.com/documentation/uikit/uiview/1622600-intrinsiccontentsize">intrinsiccontentsize</a>)</p>]]></content:encoded></item></channel></rss>